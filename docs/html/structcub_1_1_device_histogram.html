<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CUB: cub::DeviceHistogram Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecub.html">cub</a></li><li class="navelem"><a class="el" href="structcub_1_1_device_histogram.html">DeviceHistogram</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="structcub_1_1_device_histogram-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cub::DeviceHistogram Struct Reference<div class="ingroups"><a class="el" href="group___device_module.html">Device-wide</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><p><a class="el" href="structcub_1_1_device_histogram.html" title="DeviceHistogram provides device-wide parallel operations for constructing histogram(s) from a sequenc...">DeviceHistogram</a> provides device-wide parallel operations for constructing histogram(s) from a sequence of samples data residing within global memory. </p>
<div class="image">
<img src="histogram_logo.png" alt="histogram_logo.png"/>
<div class="caption">
.</div></div>
 <dl class="section user"><dt>Overview</dt><dd>A <a href="http://en.wikipedia.org/wiki/Histogram"><em>histogram</em></a> counts the number of observations that fall into each of the disjoint categories (known as <em>bins</em>).</dd></dl>
<dl class="section user"><dt>Usage Considerations</dt><dd><ul>
<li><em>Dynamic parallelism</em>. <a class="el" href="structcub_1_1_device_histogram.html" title="DeviceHistogram provides device-wide parallel operations for constructing histogram(s) from a sequenc...">DeviceHistogram</a> methods can be called within kernel code on devices in which CUDA dynamic parallelism is supported. When calling these methods from kernel code, be sure to define the <code>CUB_CDP</code> macro in your compiler's macro definitions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd></dd></dl>
<div class="image">
<img src="histo_perf.png" alt="histo_perf.png"/>
</div>
 
<p>Definition at line <a class="el" href="device__histogram_8cuh_source.html#l00066">66</a> of file <a class="el" href="device__histogram_8cuh_source.html">device_histogram.cuh</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Single-channel samples</div></td></tr>
<tr class="memitem:aee759c4bd33c74c0c5604b85eafb1c8e"><td class="memTemplParams" colspan="2">template&lt;int BINS, typename InputIterator , typename HistoCounter &gt; </td></tr>
<tr class="memitem:aee759c4bd33c74c0c5604b85eafb1c8e"><td class="memTemplItemLeft" align="right" valign="top">__host__ static __device__ <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_histogram.html#aee759c4bd33c74c0c5604b85eafb1c8e">SingleChannelSorting</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, InputIterator d_samples, HistoCounter *d_histogram, int num_samples, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:aee759c4bd33c74c0c5604b85eafb1c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a device-wide histogram using fast block-wide sorting.  <a href="#aee759c4bd33c74c0c5604b85eafb1c8e">More...</a><br/></td></tr>
<tr class="separator:aee759c4bd33c74c0c5604b85eafb1c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac572e855b8c74e8afacb5e38d9e8d912"><td class="memTemplParams" colspan="2">template&lt;int BINS, typename InputIterator , typename HistoCounter &gt; </td></tr>
<tr class="memitem:ac572e855b8c74e8afacb5e38d9e8d912"><td class="memTemplItemLeft" align="right" valign="top">__host__ static __device__ <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_histogram.html#ac572e855b8c74e8afacb5e38d9e8d912">SingleChannelSharedAtomic</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, InputIterator d_samples, HistoCounter *d_histogram, int num_samples, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:ac572e855b8c74e8afacb5e38d9e8d912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a device-wide histogram using shared-memory atomic read-modify-write operations.  <a href="#ac572e855b8c74e8afacb5e38d9e8d912">More...</a><br/></td></tr>
<tr class="separator:ac572e855b8c74e8afacb5e38d9e8d912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4028c47f439d286ab34fcbb3a0bccdd8"><td class="memTemplParams" colspan="2">template&lt;int BINS, typename InputIterator , typename HistoCounter &gt; </td></tr>
<tr class="memitem:a4028c47f439d286ab34fcbb3a0bccdd8"><td class="memTemplItemLeft" align="right" valign="top">__host__ static __device__ <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_histogram.html#a4028c47f439d286ab34fcbb3a0bccdd8">SingleChannelGlobalAtomic</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, InputIterator d_samples, HistoCounter *d_histogram, int num_samples, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a4028c47f439d286ab34fcbb3a0bccdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a device-wide histogram using global-memory atomic read-modify-write operations.  <a href="#a4028c47f439d286ab34fcbb3a0bccdd8">More...</a><br/></td></tr>
<tr class="separator:a4028c47f439d286ab34fcbb3a0bccdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interleaved multi-channel samples</div></td></tr>
<tr class="memitem:a9278e6481bf016625a0e2159e59850f6"><td class="memTemplParams" colspan="2">template&lt;int BINS, int CHANNELS, int ACTIVE_CHANNELS, typename InputIterator , typename HistoCounter &gt; </td></tr>
<tr class="memitem:a9278e6481bf016625a0e2159e59850f6"><td class="memTemplItemLeft" align="right" valign="top">__host__ static __device__ <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_histogram.html#a9278e6481bf016625a0e2159e59850f6">MultiChannelSorting</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, InputIterator d_samples, HistoCounter *d_histograms[ACTIVE_CHANNELS], int num_samples, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a9278e6481bf016625a0e2159e59850f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a device-wide histogram from multi-channel data using fast block-sorting.  <a href="#a9278e6481bf016625a0e2159e59850f6">More...</a><br/></td></tr>
<tr class="separator:a9278e6481bf016625a0e2159e59850f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4060f0707d219b7ee36e6dfa7121052b"><td class="memTemplParams" colspan="2">template&lt;int BINS, int CHANNELS, int ACTIVE_CHANNELS, typename InputIterator , typename HistoCounter &gt; </td></tr>
<tr class="memitem:a4060f0707d219b7ee36e6dfa7121052b"><td class="memTemplItemLeft" align="right" valign="top">__host__ static __device__ <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_histogram.html#a4060f0707d219b7ee36e6dfa7121052b">MultiChannelSharedAtomic</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, InputIterator d_samples, HistoCounter *d_histograms[ACTIVE_CHANNELS], int num_samples, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a4060f0707d219b7ee36e6dfa7121052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a device-wide histogram from multi-channel data using shared-memory atomic read-modify-write operations.  <a href="#a4060f0707d219b7ee36e6dfa7121052b">More...</a><br/></td></tr>
<tr class="separator:a4060f0707d219b7ee36e6dfa7121052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bc1ee2969f3baf474014ac74789806"><td class="memTemplParams" colspan="2">template&lt;int BINS, int CHANNELS, int ACTIVE_CHANNELS, typename InputIterator , typename HistoCounter &gt; </td></tr>
<tr class="memitem:a68bc1ee2969f3baf474014ac74789806"><td class="memTemplItemLeft" align="right" valign="top">__host__ static __device__ <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_histogram.html#a68bc1ee2969f3baf474014ac74789806">MultiChannelGlobalAtomic</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, InputIterator d_samples, HistoCounter *d_histograms[ACTIVE_CHANNELS], int num_samples, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a68bc1ee2969f3baf474014ac74789806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a device-wide histogram from multi-channel data using global-memory atomic read-modify-write operations.  <a href="#a68bc1ee2969f3baf474014ac74789806">More...</a><br/></td></tr>
<tr class="separator:a68bc1ee2969f3baf474014ac74789806"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aee759c4bd33c74c0c5604b85eafb1c8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int BINS, typename InputIterator , typename HistoCounter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ static __device__ cudaError_t cub::DeviceHistogram::SingleChannelSorting </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>d_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HistoCounter *&#160;</td>
          <td class="paramname"><em>d_histogram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a device-wide histogram using fast block-wide sorting. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The total number of samples across all channels (<code>num_samples</code>) must be a whole multiple of <code>CHANNELS</code>.</li>
<li>Delivers consistent throughput regardless of sample diversity</li>
<li>Histograms having a large number of bins (e.g., thousands) may adversely affect shared memory occupancy and performance (or even the ability to launch).</li>
<li>Performance is often improved when referencing input samples through a texture-caching iterator (e.g., <a class="el" href="classcub_1_1_tex_obj_input_iterator.html" title="A random-access input wrapper for dereferencing array values through texture cache. Uses newer Kepler-style texture objects. ">cub::TexObjInputIterator</a>).</li>
<li>This operation requires an allocation of temporary device storage. When <code>d_temp_storage</code> is NULL, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
<li>When calling this method from kernel code, be sure to define the <code>CUB_CDP</code> macro in your compiler's macro definitions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the computation of a 8-bin histogram of single-channel <code>unsigned char</code> samples. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_histogram.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device pointers for input and histogram</span></div>
<div class="line"><span class="keywordtype">int</span>              num_samples;    <span class="comment">// e.g., 12</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>    *d_samples;     <span class="comment">// e.g., [2, 6, 7, 5, 3, 0, 2, 1, 7, 0, 6, 2]</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     *d_histogram;   <span class="comment">// e.g., [ ,  ,  ,  ,  ,  ,  ,  ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Wrap d_samples device pointer in a random-access texture iterator</span></div>
<div class="line">cub::TexObjInputIterator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; d_samples_tex_itr;</div>
<div class="line">d_samples_tex_itr.BindTexture(d_samples, num_samples * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span> *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span> temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceHistogram::SingleChannelSorting&lt;8&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histogram, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compute histogram</span></div>
<div class="line">cub::DeviceHistogram::SingleChannelSorting&lt;8&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histogram, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Unbind texture iterator</span></div>
<div class="line">d_samples_tex_itr.UnbindTexture();</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_histogram   &lt;-- [2, 1, 3, 1, 0, 1, 2, 2]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BINS</td><td>Number of histogram bins per channel </td></tr>
    <tr><td class="paramname">InputIterator</td><td><b>[inferred]</b> Random-access input iterator type for reading input samples. (Must have an InputIterator::value_type that, when cast as an integer, falls in the range [0..BINS-1]) (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">HistoCounter</td><td><b>[inferred]</b> Integer type for counting sample occurrences per histogram bin </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_samples</td><td>Input samples </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histogram</td><td>Array of BINS counters of integral type <code>HistoCounter</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>Number of samples to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. May cause significant slowdown. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__histogram_8cuh_source.html#l00129">129</a> of file <a class="el" href="device__histogram_8cuh_source.html">device_histogram.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="ac572e855b8c74e8afacb5e38d9e8d912"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int BINS, typename InputIterator , typename HistoCounter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ static __device__ cudaError_t cub::DeviceHistogram::SingleChannelSharedAtomic </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>d_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HistoCounter *&#160;</td>
          <td class="paramname"><em>d_histogram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a device-wide histogram using shared-memory atomic read-modify-write operations. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>Input samples having lower diversity can cause performance to be degraded due to serializations from bin-collisions.</li>
<li>Histograms having a large number of bins (e.g., thousands) may adversely affect shared memory occupancy and performance (or even the ability to launch).</li>
<li>Performance is often improved when referencing input samples through a texture-caching iterator (e.g., <a class="el" href="classcub_1_1_tex_obj_input_iterator.html" title="A random-access input wrapper for dereferencing array values through texture cache. Uses newer Kepler-style texture objects. ">cub::TexObjInputIterator</a>).</li>
<li>This operation requires an allocation of temporary device storage. When <code>d_temp_storage</code> is NULL, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
<li>When calling this method from kernel code, be sure to define the <code>CUB_CDP</code> macro in your compiler's macro definitions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the computation of a 8-bin histogram of single-channel <code>unsigned char</code> samples. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_histogram.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device pointers for input and histogram</span></div>
<div class="line"><span class="keywordtype">int</span>              num_samples;    <span class="comment">// e.g., 12</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>    *d_samples;     <span class="comment">// e.g., [2, 6, 7, 5, 3, 0, 2, 1, 7, 0, 6, 2]</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     *d_histogram;   <span class="comment">// e.g., [ ,  ,  ,  ,  ,  ,  ,  ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Wrap d_samples device pointer in a random-access texture iterator</span></div>
<div class="line">cub::TexObjInputIterator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; d_samples_tex_itr;</div>
<div class="line">d_samples_tex_itr.BindTexture(d_samples, num_samples * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceHistogram::SingleChannelSorting&lt;8&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histogram, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compute histogram</span></div>
<div class="line">cub::DeviceHistogram::SingleChannelSharedAtomic&lt;8&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histogram, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Unbind texture iterator</span></div>
<div class="line">d_samples_tex_itr.UnbindTexture();</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_histogram   &lt;-- [2, 1, 3, 1, 0, 1, 2, 2]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BINS</td><td>Number of histogram bins per channel </td></tr>
    <tr><td class="paramname">InputIterator</td><td><b>[inferred]</b> Random-access input iterator type for reading input samples. (Must have an InputIterator::value_type that, when cast as an integer, falls in the range [0..BINS-1]) (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">HistoCounter</td><td><b>[inferred]</b> Integer type for counting sample occurrences per histogram bin </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_samples</td><td>Input samples </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histogram</td><td>Array of BINS counters of integral type <code>HistoCounter</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>Number of samples to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. May cause significant slowdown. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__histogram_8cuh_source.html#l00217">217</a> of file <a class="el" href="device__histogram_8cuh_source.html">device_histogram.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a4028c47f439d286ab34fcbb3a0bccdd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int BINS, typename InputIterator , typename HistoCounter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ static __device__ cudaError_t cub::DeviceHistogram::SingleChannelGlobalAtomic </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>d_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HistoCounter *&#160;</td>
          <td class="paramname"><em>d_histogram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a device-wide histogram using global-memory atomic read-modify-write operations. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>Input samples having lower diversity can cause performance to be degraded due to serializations from bin-collisions.</li>
<li>Performance is not significantly impacted when computing histograms having large numbers of bins (e.g., thousands).</li>
<li>Performance is often improved when referencing input samples through a texture-caching iterator (e.g., <a class="el" href="classcub_1_1_tex_obj_input_iterator.html" title="A random-access input wrapper for dereferencing array values through texture cache. Uses newer Kepler-style texture objects. ">cub::TexObjInputIterator</a>).</li>
<li>This operation requires an allocation of temporary device storage. When <code>d_temp_storage</code> is NULL, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
<li>When calling this method from kernel code, be sure to define the <code>CUB_CDP</code> macro in your compiler's macro definitions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the computation of a 8-bin histogram of single-channel <code>unsigned char</code> samples. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_histogram.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device pointers for input and histogram</span></div>
<div class="line"><span class="keywordtype">int</span>              num_samples;    <span class="comment">// e.g., 12</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>    *d_samples;     <span class="comment">// e.g., [2, 6, 7, 5, 3, 0, 2, 1, 7, 0, 6, 2]</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     *d_histogram;   <span class="comment">// e.g., [ ,  ,  ,  ,  ,  ,  ,  ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Wrap d_samples device pointer in a random-access texture iterator</span></div>
<div class="line">cub::TexObjInputIterator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; d_samples_tex_itr;</div>
<div class="line">d_samples_tex_itr.BindTexture(d_samples, num_samples * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceHistogram::SingleChannelSorting&lt;8&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histogram, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compute histogram</span></div>
<div class="line">cub::DeviceHistogram::SingleChannelGlobalAtomic&lt;8&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histogram, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Unbind texture iterator</span></div>
<div class="line">d_samples_tex_itr.UnbindTexture();</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_histogram   &lt;-- [2, 1, 3, 1, 0, 1, 2, 2]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BINS</td><td>Number of histogram bins per channel </td></tr>
    <tr><td class="paramname">InputIterator</td><td><b>[inferred]</b> Random-access input iterator type for reading input samples. (Must have an InputIterator::value_type that, when cast as an integer, falls in the range [0..BINS-1]) (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">HistoCounter</td><td><b>[inferred]</b> Integer type for counting sample occurrences per histogram bin </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_samples</td><td>Input samples </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histogram</td><td>Array of BINS counters of integral type <code>HistoCounter</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>Number of samples to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. May cause significant slowdown. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__histogram_8cuh_source.html#l00305">305</a> of file <a class="el" href="device__histogram_8cuh_source.html">device_histogram.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a9278e6481bf016625a0e2159e59850f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int BINS, int CHANNELS, int ACTIVE_CHANNELS, typename InputIterator , typename HistoCounter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ static __device__ cudaError_t cub::DeviceHistogram::MultiChannelSorting </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>d_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HistoCounter *&#160;</td>
          <td class="paramname"><em>d_histograms</em>[ACTIVE_CHANNELS], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a device-wide histogram from multi-channel data using fast block-sorting. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The total number of samples across all channels (<code>num_samples</code>) must be a whole multiple of <code>CHANNELS</code>.</li>
<li>Delivers consistent throughput regardless of sample diversity</li>
<li>Histograms having a large number of bins (e.g., thousands) may adversely affect shared memory occupancy and performance (or even the ability to launch).</li>
<li>Performance is often improved when referencing input samples through a texture-caching iterator (e.g., <a class="el" href="classcub_1_1_tex_obj_input_iterator.html" title="A random-access input wrapper for dereferencing array values through texture cache. Uses newer Kepler-style texture objects. ">cub::TexObjInputIterator</a>).</li>
<li>This operation requires an allocation of temporary device storage. When <code>d_temp_storage</code> is NULL, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
<li>When calling this method from kernel code, be sure to define the <code>CUB_CDP</code> macro in your compiler's macro definitions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the computation of three 256-bin histograms from an input sequence of quad-channel (interleaved) <code>unsigned char</code> samples. (E.g., RGB histograms from RGBA pixel samples.)</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_histogram.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device pointers for input and histograms</span></div>
<div class="line"><span class="keywordtype">int</span>           num_samples;     <span class="comment">// e.g., 20 (five pixels with four channels each)</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *d_samples;      <span class="comment">// e.g., [(2, 6, 7, 5), (3, 0, 2, 1), (7, 0, 6, 2),</span></div>
<div class="line">                               <span class="comment">//        (0, 6, 7, 5), (3, 0, 2, 6)]</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  *d_histogram[3]; <span class="comment">// e.g., [ [ ,  ,  ,  ,  ,  ,  ,  ];</span></div>
<div class="line">                               <span class="comment">//         [ ,  ,  ,  ,  ,  ,  ,  ];</span></div>
<div class="line">                               <span class="comment">//         [ ,  ,  ,  ,  ,  ,  ,  ] ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Wrap d_samples device pointer in a random-access texture iterator</span></div>
<div class="line">cub::TexObjInputIterator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; d_samples_tex_itr;</div>
<div class="line">d_samples_tex_itr.BindTexture(d_samples, num_samples * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceHistogram::MultiChannelSorting&lt;8, 4, 3&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histograms, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compute histograms</span></div>
<div class="line">cub::DeviceHistogram::MultiChannelSorting&lt;8, 4, 3&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histograms, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Unbind texture iterator</span></div>
<div class="line">d_samples_tex_itr.UnbindTexture();</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_histogram   &lt;-- [ [1, 0, 1, 2, 0, 0, 0, 1];</span></div>
<div class="line"><span class="comment">//                     [0, 3, 0, 0, 0, 0, 2, 0];</span></div>
<div class="line"><span class="comment">//                     [0, 0, 2, 0, 0, 0, 1, 2] ]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BINS</td><td>Number of histogram bins per channel </td></tr>
    <tr><td class="paramname">CHANNELS</td><td>Number of channels interleaved in the input data (may be greater than the number of channels being actively histogrammed) </td></tr>
    <tr><td class="paramname">ACTIVE_CHANNELS</td><td><b>[inferred]</b> Number of channels actively being histogrammed </td></tr>
    <tr><td class="paramname">InputIterator</td><td><b>[inferred]</b> Random-access input iterator type for reading input samples. (Must have an InputIterator::value_type that, when cast as an integer, falls in the range [0..BINS-1]) (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">HistoCounter</td><td><b>[inferred]</b> Integer type for counting sample occurrences per histogram bin </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_samples</td><td>Pointer to the input sequence of sample items. The samples from different channels are assumed to be interleaved (e.g., an array of 32b pixels where each pixel consists of four RGBA 8b samples). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histograms</td><td>Array of active channel histogram pointers, each pointing to an output array having BINS counters of integral type <code>HistoCounter</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>Total number of samples to process in all channels, including non-active channels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. May cause significant slowdown. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__histogram_8cuh_source.html#l00412">412</a> of file <a class="el" href="device__histogram_8cuh_source.html">device_histogram.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a4060f0707d219b7ee36e6dfa7121052b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int BINS, int CHANNELS, int ACTIVE_CHANNELS, typename InputIterator , typename HistoCounter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ static __device__ cudaError_t cub::DeviceHistogram::MultiChannelSharedAtomic </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>d_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HistoCounter *&#160;</td>
          <td class="paramname"><em>d_histograms</em>[ACTIVE_CHANNELS], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a device-wide histogram from multi-channel data using shared-memory atomic read-modify-write operations. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The total number of samples across all channels (<code>num_samples</code>) must be a whole multiple of <code>CHANNELS</code>.</li>
<li>Input samples having lower diversity can cause performance to be degraded due to serializations from bin-collisions.</li>
<li>Histograms having a large number of bins (e.g., thousands) may adversely affect shared memory occupancy and performance (or even the ability to launch).</li>
<li>Performance is often improved when referencing input samples through a texture-caching iterator (e.g., <a class="el" href="classcub_1_1_tex_obj_input_iterator.html" title="A random-access input wrapper for dereferencing array values through texture cache. Uses newer Kepler-style texture objects. ">cub::TexObjInputIterator</a>).</li>
<li>This operation requires an allocation of temporary device storage. When <code>d_temp_storage</code> is NULL, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
<li>When calling this method from kernel code, be sure to define the <code>CUB_CDP</code> macro in your compiler's macro definitions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the computation of three 256-bin histograms from an input sequence of quad-channel (interleaved) <code>unsigned char</code> samples. (E.g., RGB histograms from RGBA pixel samples.) </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_histogram.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device pointers for input and histograms</span></div>
<div class="line"><span class="keywordtype">int</span>           num_samples;     <span class="comment">// e.g., 20 (five pixels with four channels each)</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *d_samples;      <span class="comment">// e.g., [(2, 6, 7, 5), (3, 0, 2, 1), (7, 0, 6, 2),</span></div>
<div class="line">                               <span class="comment">//        (0, 6, 7, 5), (3, 0, 2, 6)]</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  *d_histogram[3]; <span class="comment">// e.g., [ [ ,  ,  ,  ,  ,  ,  ,  ];</span></div>
<div class="line">                               <span class="comment">//         [ ,  ,  ,  ,  ,  ,  ,  ];</span></div>
<div class="line">                               <span class="comment">//         [ ,  ,  ,  ,  ,  ,  ,  ] ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Wrap d_samples device pointer in a random-access texture iterator</span></div>
<div class="line">cub::TexObjInputIterator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; d_samples_tex_itr;</div>
<div class="line">d_samples_tex_itr.BindTexture(d_samples, num_samples * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span> *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span> temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceHistogram::MultiChannelSharedAtomic&lt;8, 4, 3&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histograms, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compute histograms</span></div>
<div class="line">cub::DeviceHistogram::MultiChannelSharedAtomic&lt;8, 4, 3&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histograms, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Unbind texture iterator</span></div>
<div class="line">d_samples_tex_itr.UnbindTexture();</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_histogram   &lt;-- [ [1, 0, 1, 2, 0, 0, 0, 1];</span></div>
<div class="line"><span class="comment">//                     [0, 3, 0, 0, 0, 0, 2, 0];</span></div>
<div class="line"><span class="comment">//                     [0, 0, 2, 0, 0, 0, 1, 2] ]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BINS</td><td>Number of histogram bins per channel </td></tr>
    <tr><td class="paramname">CHANNELS</td><td>Number of channels interleaved in the input data (may be greater than the number of channels being actively histogrammed) </td></tr>
    <tr><td class="paramname">ACTIVE_CHANNELS</td><td><b>[inferred]</b> Number of channels actively being histogrammed </td></tr>
    <tr><td class="paramname">InputIterator</td><td><b>[inferred]</b> Random-access input iterator type for reading input samples. (Must have an InputIterator::value_type that, when cast as an integer, falls in the range [0..BINS-1]) (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">HistoCounter</td><td><b>[inferred]</b> Integer type for counting sample occurrences per histogram bin </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_samples</td><td>Pointer to the input sequence of sample items. The samples from different channels are assumed to be interleaved (e.g., an array of 32b pixels where each pixel consists of four RGBA 8b samples). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histograms</td><td>Array of active channel histogram pointers, each pointing to an output array having BINS counters of integral type <code>HistoCounter</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>Total number of samples to process in all channels, including non-active channels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. May cause significant slowdown. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__histogram_8cuh_source.html#l00510">510</a> of file <a class="el" href="device__histogram_8cuh_source.html">device_histogram.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a68bc1ee2969f3baf474014ac74789806"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int BINS, int CHANNELS, int ACTIVE_CHANNELS, typename InputIterator , typename HistoCounter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__host__ static __device__ cudaError_t cub::DeviceHistogram::MultiChannelGlobalAtomic </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>d_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HistoCounter *&#160;</td>
          <td class="paramname"><em>d_histograms</em>[ACTIVE_CHANNELS], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a device-wide histogram from multi-channel data using global-memory atomic read-modify-write operations. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The total number of samples across all channels (<code>num_samples</code>) must be a whole multiple of <code>CHANNELS</code>.</li>
<li>Input samples having lower diversity can cause performance to be degraded due to serializations from bin-collisions.</li>
<li>Performance is not significantly impacted when computing histograms having large numbers of bins (e.g., thousands).</li>
<li>Performance is often improved when referencing input samples through a texture-caching iterator (e.g., <a class="el" href="classcub_1_1_tex_obj_input_iterator.html" title="A random-access input wrapper for dereferencing array values through texture cache. Uses newer Kepler-style texture objects. ">cub::TexObjInputIterator</a>).</li>
<li>This operation requires an allocation of temporary device storage. When <code>d_temp_storage</code> is NULL, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
<li>When calling this method from kernel code, be sure to define the <code>CUB_CDP</code> macro in your compiler's macro definitions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the computation of three 256-bin histograms from an input sequence of quad-channel (interleaved) <code>unsigned char</code> samples. (E.g., RGB histograms from RGBA pixel samples.)</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_histogram.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device pointers for input and histograms</span></div>
<div class="line"><span class="keywordtype">int</span>           num_samples;     <span class="comment">// e.g., 20 (five pixels with four channels each)</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *d_samples;      <span class="comment">// e.g., [(2, 6, 7, 5), (3, 0, 2, 1), (7, 0, 6, 2),</span></div>
<div class="line">                               <span class="comment">//        (0, 6, 7, 5), (3, 0, 2, 6)]</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  *d_histogram[3]; <span class="comment">// e.g., [ [ ,  ,  ,  ,  ,  ,  ,  ];</span></div>
<div class="line">                               <span class="comment">//         [ ,  ,  ,  ,  ,  ,  ,  ];</span></div>
<div class="line">                               <span class="comment">//         [ ,  ,  ,  ,  ,  ,  ,  ] ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Wrap d_samples device pointer in a random-access texture iterator</span></div>
<div class="line">cub::TexObjInputIterator&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt; d_samples_tex_itr;</div>
<div class="line">d_samples_tex_itr.BindTexture(d_samples, num_samples * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceHistogram::MultiChannelGlobalAtomic&lt;8, 4, 3&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histograms, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compute histograms</span></div>
<div class="line">cub::DeviceHistogram::MultiChannelGlobalAtomic&lt;8, 4, 3&gt;(d_temp_storage, temp_storage_bytes, d_samples_tex_itr, d_histograms, num_samples);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Unbind texture iterator</span></div>
<div class="line">d_samples_tex_itr.UnbindTexture();</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_histogram   &lt;-- [ [1, 0, 1, 2, 0, 0, 0, 1];</span></div>
<div class="line"><span class="comment">//                     [0, 3, 0, 0, 0, 0, 2, 0];</span></div>
<div class="line"><span class="comment">//                     [0, 0, 2, 0, 0, 0, 1, 2] ]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BINS</td><td>Number of histogram bins per channel </td></tr>
    <tr><td class="paramname">CHANNELS</td><td>Number of channels interleaved in the input data (may be greater than the number of channels being actively histogrammed) </td></tr>
    <tr><td class="paramname">ACTIVE_CHANNELS</td><td><b>[inferred]</b> Number of channels actively being histogrammed </td></tr>
    <tr><td class="paramname">InputIterator</td><td><b>[inferred]</b> Random-access input iterator type for reading input samples. (Must have an InputIterator::value_type that, when cast as an integer, falls in the range [0..BINS-1]) (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">HistoCounter</td><td><b>[inferred]</b> Integer type for counting sample occurrences per histogram bin </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_samples</td><td>Pointer to the input sequence of sample items. The samples from different channels are assumed to be interleaved (e.g., an array of 32b pixels where each pixel consists of four RGBA 8b samples). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_histograms</td><td>Array of active channel histogram pointers, each pointing to an output array having BINS counters of integral type <code>HistoCounter</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>Total number of samples to process in all channels, including non-active channels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. May cause significant slowdown. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__histogram_8cuh_source.html#l00609">609</a> of file <a class="el" href="device__histogram_8cuh_source.html">device_histogram.cuh</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="device__histogram_8cuh_source.html">device_histogram.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 1 2014 16:19:43 for CUB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
<br>
&copy; 2013 NVIDIA Corporation
</small></address>
</body>
</html>
