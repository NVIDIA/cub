<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>CUB: cub::BlockScan&lt; T, BLOCK_THREADS, POLICY &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecub.html">cub</a></li><li class="navelem"><a class="el" href="classcub_1_1_block_scan.html">BlockScan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="classcub_1_1_block_scan-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cub::BlockScan&lt; T, BLOCK_THREADS, POLICY &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___simt_coop.html">Cooperative SIMT Operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><h3>template&lt;typename T, int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt;<br/>
class cub::BlockScan&lt; T, BLOCK_THREADS, POLICY &gt;</h3>

<p><a class="el" href="classcub_1_1_block_scan.html" title="BlockScan provides variants of parallel prefix scan (and prefix sum) across a CUDA threadblock...">BlockScan</a> provides variants of parallel prefix scan (and prefix sum) across a CUDA threadblock. </p>
<div class="image">
<img src="scan_logo.png" alt="scan_logo.png"/>
<div class="caption">
.</div></div>
 <dl class="section user"><dt>Overview</dt><dd>Given a list of input elements and a binary reduction operator, a <a href="http://en.wikipedia.org/wiki/Prefix_sum"><em>prefix scan</em></a> produces an output list where each element is computed to be the reduction of the elements occurring earlier in the input list. <em>Prefix sum</em> connotes a prefix scan with the addition operator. The term <em>inclusive</em> indicates that the <em>i</em><sup>th</sup> output reduction includes the <em>i</em><sup>th</sup> input. The term <em>exclusive</em> indicates the <em>i</em><sup>th</sup> input is not computed into the <em>i</em><sup>th</sup> output reduction.</dd></dl>
<dl class="section user"><dt></dt><dd>For convenience, <a class="el" href="classcub_1_1_block_scan.html" title="BlockScan provides variants of parallel prefix scan (and prefix sum) across a CUDA threadblock...">BlockScan</a> exposes a spectrum of entrypoints that differ by:<ul>
<li>Operator (generic scan <em>vs.</em> prefix sum for numeric types)</li>
<li>Granularity (single <em>vs.</em> multiple items per thread)</li>
<li>Output ordering (inclusive <em>vs.</em> exclusive)</li>
<li>Block-wide prefix (identity <em>vs.</em> call-back functor)</li>
<li>Output (scanned elements only <em>vs.</em> scanned elements and the total aggregate)</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Furthermore, <a class="el" href="classcub_1_1_block_scan.html" title="BlockScan provides variants of parallel prefix scan (and prefix sum) across a CUDA threadblock...">BlockScan</a> provides a single prefix scan abstraction whose performance behavior can be tuned externally. In particular, <a class="el" href="classcub_1_1_block_scan.html" title="BlockScan provides variants of parallel prefix scan (and prefix sum) across a CUDA threadblock...">BlockScan</a> implements alternative <a class="el" href="namespacecub.html#aa7484021273cbfd89229a6b5c205b9f1" title="Tuning policy for cub::BlockScan.">cub::BlockScanPolicy</a> strategies catering to different latency/throughput needs.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The reduction input/output element type </td></tr>
    <tr><td class="paramname">BLOCK_THREADS</td><td>The threadblock size in threads </td></tr>
    <tr><td class="paramname">POLICY</td><td><b>[optional]</b> <a class="el" href="namespacecub.html#aa7484021273cbfd89229a6b5c205b9f1" title="Tuning policy for cub::BlockScan.">cub::BlockScanPolicy</a> tuning policy. Default = <a class="el" href="namespacecub.html#aa7484021273cbfd89229a6b5c205b9f1a0fa6cac57b7df2f475a67af053b9371c">cub::BLOCK_SCAN_RAKING</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Algorithm</dt><dd><a class="el" href="classcub_1_1_block_scan.html" title="BlockScan provides variants of parallel prefix scan (and prefix sum) across a CUDA threadblock...">BlockScan</a> can be (optionally) configured to use different algorithms:<ol type="1">
<li><b><a class="el" href="namespacecub.html#aa7484021273cbfd89229a6b5c205b9f1a0fa6cac57b7df2f475a67af053b9371c">cub::BLOCK_SCAN_RAKING</a></b>. An efficient "raking reduce-then-scan" prefix scan algorithm. <a class="el" href="namespacecub.html#aa7484021273cbfd89229a6b5c205b9f1">More...</a></li>
<li><b><a class="el" href="namespacecub.html#aa7484021273cbfd89229a6b5c205b9f1a08bbb9b8f17a4b9e568c1333aeda6324">cub::BLOCK_SCAN_WARPSCANS</a></b>. A quick "tiled warpscans" prefix scan algorithm. <a class="el" href="namespacecub.html#aa7484021273cbfd89229a6b5c205b9f1">More...</a></li>
</ol>
</dd></dl>
<dl class="section user"><dt>Usage Considerations</dt><dd><ul>
<li>Supports non-commutative scan operators</li>
<li>Assumes a <a href="index.html#sec3sec3"><em>blocked arrangement</em></a> of elements across threads</li>
<li>Any threadblock-wide scalar inputs and outputs (e.g., <code>block_prefix_op</code> and <code>block_aggregate</code>) are only considered valid in <em>thread</em><sub>0</sub></li>
<li>After any operation, a subsequent <code>__syncthreads()</code> barrier is required if the supplied <a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64" title="The operations exposed by BlockScan require shared memory of this type. This opaque storage can be al...">BlockScan::SmemStorage</a> is to be reused or repurposed by the threadblock</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance Considerations</dt><dd><ul>
<li>Uses special instructions when applicable (e.g., warp <code>SHFL</code>)</li>
<li>Uses synchronization-free communication between warp lanes when applicable</li>
<li>Uses only one or two threadblock-wide synchronization barriers (depending on algorithm selection)</li>
<li>Zero bank conflicts for most types</li>
<li>Computation is slightly more efficient (i.e., having lower instruction overhead) for:<ul>
<li>Prefix sum variants (<em>vs.</em> generic scan)</li>
<li>Exclusive variants (<em>vs.</em> inclusive)</li>
<li>Basic scan variants that don't require scalar inputs and outputs (e.g., <code>block_prefix_op</code> and <code>block_aggregate</code>)</li>
<li><code>T</code> is a built-in C++ primitive or CUDA vector type (e.g., <code>short</code>, <code>int2</code>, <code>double</code>, <code>float2</code>, etc.)</li>
<li><code>BLOCK_THREADS</code> is a multiple of the architecture's warp size</li>
</ul>
</li>
<li>See <a class="el" href="namespacecub.html#aa7484021273cbfd89229a6b5c205b9f1" title="Tuning policy for cub::BlockScan.">cub::BlockScanPolicy</a> for more performance details regarding algorithmic alternatives</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><em>Example 1.</em> Perform a simple exclusive prefix sum of 512 integer keys that are partitioned in a blocked arrangement across a 128-thread threadblock (where each thread holds 4 keys). <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cub.cuh&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> SomeKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Parameterize BlockScan for the parallel execution context</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_block_scan.html" title="BlockScan provides variants of parallel prefix scan (and prefix sum) across a CUDA threadblock...">cub::BlockScan&lt;int, 128&gt;</a> BlockScan;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Declare shared memory for BlockScan</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> <a class="code" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64" title="The operations exposed by BlockScan require shared memory of this type. This opaque storage can be al...">BlockScan::SmemStorage</a> smem_storage;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// A segment of consecutive input items per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> data[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain items in blocked order</span></div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute the threadblock-wide exclusve prefix sum</span></div>
<div class="line">    <a class="code" href="classcub_1_1_block_scan.html#a01676b552903e7b5d240bbde7968d55e" title="Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator...">BlockScan::ExclusiveSum</a>(smem_storage, data, data);</div>
<div class="line"></div>
<div class="line">    ...</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd><em>Example 2:</em> Perform inter-threadblock allocation within a global data structure by using local prefix sum that incorporates a single global atomic-add. <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cub.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>BlockPrefixOp</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> *d_global_counter;</div>
<div class="line"></div>
<div class="line">    __device__ BlockPrefixOp(<span class="keywordtype">int</span> *d_global_counter) : d_global_counter(d_global_counter) {}</div>
<div class="line"></div>
<div class="line">    __device__ <span class="keywordtype">int</span> operator(<span class="keywordtype">int</span> block_aggregate)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (threadIdx.x == 0) ?</div>
<div class="line">            atomicAdd(d_global_counter, block_aggregate) :      <span class="comment">// thread0</span></div>
<div class="line">            0;                                                  <span class="comment">// anybody else</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> BLOCK_THREADS, <span class="keywordtype">int</span> ITEMS_PER_THREAD&gt;</div>
<div class="line">__global__ <span class="keywordtype">void</span> SomeKernel(<span class="keywordtype">int</span> *d_global_counter, ...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Parameterize BlockScan for the parallel execution context</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_block_scan.html" title="BlockScan provides variants of parallel prefix scan (and prefix sum) across a CUDA threadblock...">cub::BlockScan&lt;int, BLOCK_THREADS&gt;</a> BlockScan;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Declare shared memory for BlockScan</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> <a class="code" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64" title="The operations exposed by BlockScan require shared memory of this type. This opaque storage can be al...">BlockScan::SmemStorage</a> smem_storage;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// A segment of consecutive input items per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> data[ITEMS_PER_THREAD];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain keys in blocked order</span></div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute the threadblock-wide exclusive prefix sum, seeded with a threadblock-wide prefix</span></div>
<div class="line">    <span class="keywordtype">int</span> aggregate;</div>
<div class="line">    <a class="code" href="classcub_1_1_block_scan.html#a01676b552903e7b5d240bbde7968d55e" title="Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator...">BlockScan::ExclusiveSum</a>(smem_storage, data, data, block_aggregate, BlockPrefix(d_global_counter));</div>
</div><!-- fragment --> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abda6008896e2e17b50c7deb0ab320e64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abda6008896e2e17b50c7deb0ab320e64"></a>
typedef _SmemStorage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a></td></tr>
<tr class="memdesc:abda6008896e2e17b50c7deb0ab320e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operations exposed by <a class="el" href="classcub_1_1_block_scan.html" title="BlockScan provides variants of parallel prefix scan (and prefix sum) across a CUDA threadblock...">BlockScan</a> require shared memory of this type. This opaque storage can be allocated directly using the <code>__shared__</code> keyword. Alternatively, it can be aliased to externally allocated shared memory or <code>union</code>'d with other types to facilitate shared memory reuse. <br/></td></tr>
<tr class="separator:abda6008896e2e17b50c7deb0ab320e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Exclusive prefix scans</div></td></tr>
<tr class="memitem:acc948eb8877a6d9956daebf258119b7a"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:acc948eb8877a6d9956daebf258119b7a"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#acc948eb8877a6d9956daebf258119b7a">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, const T &amp;identity, ScanOp scan_op, T &amp;block_aggregate)</td></tr>
<tr class="memdesc:acc948eb8877a6d9956daebf258119b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#acc948eb8877a6d9956daebf258119b7a">More...</a><br/></td></tr>
<tr class="separator:acc948eb8877a6d9956daebf258119b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fbe22df260c4731536e1bbcec70cf6"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </td></tr>
<tr class="memitem:a64fbe22df260c4731536e1bbcec70cf6"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a64fbe22df260c4731536e1bbcec70cf6">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], const T &amp;identity, ScanOp scan_op, T &amp;block_aggregate)</td></tr>
<tr class="memdesc:a64fbe22df260c4731536e1bbcec70cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#a64fbe22df260c4731536e1bbcec70cf6">More...</a><br/></td></tr>
<tr class="separator:a64fbe22df260c4731536e1bbcec70cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa858e1cc0cee3e54fc3fb00bc0ecb3ca"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp , typename BlockPrefixOp &gt; </td></tr>
<tr class="memitem:aa858e1cc0cee3e54fc3fb00bc0ecb3ca"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#aa858e1cc0cee3e54fc3fb00bc0ecb3ca">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T identity, ScanOp scan_op, T &amp;block_aggregate, BlockPrefixOp &amp;block_prefix_op)</td></tr>
<tr class="memdesc:aa858e1cc0cee3e54fc3fb00bc0ecb3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#aa858e1cc0cee3e54fc3fb00bc0ecb3ca">More...</a><br/></td></tr>
<tr class="separator:aa858e1cc0cee3e54fc3fb00bc0ecb3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7bf6b9e06e0ed3a71931f1694359f5"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename ScanOp , typename BlockPrefixOp &gt; </td></tr>
<tr class="memitem:a2a7bf6b9e06e0ed3a71931f1694359f5"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a2a7bf6b9e06e0ed3a71931f1694359f5">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], T identity, ScanOp scan_op, T &amp;block_aggregate, BlockPrefixOp &amp;block_prefix_op)</td></tr>
<tr class="memdesc:a2a7bf6b9e06e0ed3a71931f1694359f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#a2a7bf6b9e06e0ed3a71931f1694359f5">More...</a><br/></td></tr>
<tr class="separator:a2a7bf6b9e06e0ed3a71931f1694359f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86857a9daede055f69299caff5b16259"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a86857a9daede055f69299caff5b16259"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a86857a9daede055f69299caff5b16259">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T identity, ScanOp scan_op)</td></tr>
<tr class="memdesc:a86857a9daede055f69299caff5b16259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element.  <a href="#a86857a9daede055f69299caff5b16259">More...</a><br/></td></tr>
<tr class="separator:a86857a9daede055f69299caff5b16259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdb196b18b1d0eb3f7f85a57ed3ac7e"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </td></tr>
<tr class="memitem:a2cdb196b18b1d0eb3f7f85a57ed3ac7e"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a2cdb196b18b1d0eb3f7f85a57ed3ac7e">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], const T &amp;identity, ScanOp scan_op)</td></tr>
<tr class="memdesc:a2cdb196b18b1d0eb3f7f85a57ed3ac7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements.  <a href="#a2cdb196b18b1d0eb3f7f85a57ed3ac7e">More...</a><br/></td></tr>
<tr class="separator:a2cdb196b18b1d0eb3f7f85a57ed3ac7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exclusive prefix scans (without supplied identity)</div></td></tr>
<tr class="memitem:a1a0090740c3b47eb018831f36d4fe307"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a1a0090740c3b47eb018831f36d4fe307"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a1a0090740c3b47eb018831f36d4fe307">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op, T &amp;block_aggregate)</td></tr>
<tr class="memdesc:a1a0090740c3b47eb018831f36d4fe307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. With no identity value, the output computed for <em>thread</em><sub>0</sub> is invalid.  <a href="#a1a0090740c3b47eb018831f36d4fe307">More...</a><br/></td></tr>
<tr class="separator:a1a0090740c3b47eb018831f36d4fe307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929f90d956502a7142fa780647241bf0"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </td></tr>
<tr class="memitem:a929f90d956502a7142fa780647241bf0"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a929f90d956502a7142fa780647241bf0">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], ScanOp scan_op, T &amp;block_aggregate)</td></tr>
<tr class="memdesc:a929f90d956502a7142fa780647241bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. With no identity value, the output computed for <em>thread</em><sub>0</sub> is invalid.  <a href="#a929f90d956502a7142fa780647241bf0">More...</a><br/></td></tr>
<tr class="separator:a929f90d956502a7142fa780647241bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea795b16f8a66dbbef62952b5f73643"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp , typename BlockPrefixOp &gt; </td></tr>
<tr class="memitem:aaea795b16f8a66dbbef62952b5f73643"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#aaea795b16f8a66dbbef62952b5f73643">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op, T &amp;block_aggregate, BlockPrefixOp &amp;block_prefix_op)</td></tr>
<tr class="memdesc:aaea795b16f8a66dbbef62952b5f73643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#aaea795b16f8a66dbbef62952b5f73643">More...</a><br/></td></tr>
<tr class="separator:aaea795b16f8a66dbbef62952b5f73643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc79e233524e1e357a4cb77c44a46957"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename ScanOp , typename BlockPrefixOp &gt; </td></tr>
<tr class="memitem:afc79e233524e1e357a4cb77c44a46957"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#afc79e233524e1e357a4cb77c44a46957">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], ScanOp scan_op, T &amp;block_aggregate, BlockPrefixOp &amp;block_prefix_op)</td></tr>
<tr class="memdesc:afc79e233524e1e357a4cb77c44a46957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#afc79e233524e1e357a4cb77c44a46957">More...</a><br/></td></tr>
<tr class="separator:afc79e233524e1e357a4cb77c44a46957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c65595bc59cf1bb0fd04965f3b0988"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a05c65595bc59cf1bb0fd04965f3b0988"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a05c65595bc59cf1bb0fd04965f3b0988">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op)</td></tr>
<tr class="memdesc:a05c65595bc59cf1bb0fd04965f3b0988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. With no identity value, the output computed for <em>thread</em><sub>0</sub> is invalid.  <a href="#a05c65595bc59cf1bb0fd04965f3b0988">More...</a><br/></td></tr>
<tr class="separator:a05c65595bc59cf1bb0fd04965f3b0988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d2690770ba251c6da988936f248da5"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </td></tr>
<tr class="memitem:ac8d2690770ba251c6da988936f248da5"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#ac8d2690770ba251c6da988936f248da5">ExclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], ScanOp scan_op)</td></tr>
<tr class="memdesc:ac8d2690770ba251c6da988936f248da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. With no identity value, the output computed for <em>thread</em><sub>0</sub> is invalid.  <a href="#ac8d2690770ba251c6da988936f248da5">More...</a><br/></td></tr>
<tr class="separator:ac8d2690770ba251c6da988936f248da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exclusive prefix sums</div></td></tr>
<tr class="memitem:a01676b552903e7b5d240bbde7968d55e"><td class="memItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a01676b552903e7b5d240bbde7968d55e">ExclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T &amp;block_aggregate)</td></tr>
<tr class="memdesc:a01676b552903e7b5d240bbde7968d55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#a01676b552903e7b5d240bbde7968d55e">More...</a><br/></td></tr>
<tr class="separator:a01676b552903e7b5d240bbde7968d55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b6abbc17343b897a7b93d581620164"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD&gt; </td></tr>
<tr class="memitem:aa4b6abbc17343b897a7b93d581620164"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#aa4b6abbc17343b897a7b93d581620164">ExclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], T &amp;block_aggregate)</td></tr>
<tr class="memdesc:aa4b6abbc17343b897a7b93d581620164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#aa4b6abbc17343b897a7b93d581620164">More...</a><br/></td></tr>
<tr class="separator:aa4b6abbc17343b897a7b93d581620164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fb65e2f9663daaee32390dee4c786b"><td class="memTemplParams" colspan="2">template&lt;typename BlockPrefixOp &gt; </td></tr>
<tr class="memitem:af0fb65e2f9663daaee32390dee4c786b"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#af0fb65e2f9663daaee32390dee4c786b">ExclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T &amp;block_aggregate, BlockPrefixOp &amp;block_prefix_op)</td></tr>
<tr class="memdesc:af0fb65e2f9663daaee32390dee4c786b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element. Instead of using 0 as the threadblock-wide prefix, the call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#af0fb65e2f9663daaee32390dee4c786b">More...</a><br/></td></tr>
<tr class="separator:af0fb65e2f9663daaee32390dee4c786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adb14da21b88da067e0dae60c628183"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename BlockPrefixOp &gt; </td></tr>
<tr class="memitem:a9adb14da21b88da067e0dae60c628183"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a9adb14da21b88da067e0dae60c628183">ExclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], T &amp;block_aggregate, BlockPrefixOp &amp;block_prefix_op)</td></tr>
<tr class="memdesc:a9adb14da21b88da067e0dae60c628183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements. Instead of using 0 as the threadblock-wide prefix, the call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#a9adb14da21b88da067e0dae60c628183">More...</a><br/></td></tr>
<tr class="separator:a9adb14da21b88da067e0dae60c628183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e661f683b84c496a0f1bcd96d5bb528"><td class="memItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a8e661f683b84c496a0f1bcd96d5bb528">ExclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output)</td></tr>
<tr class="memdesc:a8e661f683b84c496a0f1bcd96d5bb528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element.  <a href="#a8e661f683b84c496a0f1bcd96d5bb528">More...</a><br/></td></tr>
<tr class="separator:a8e661f683b84c496a0f1bcd96d5bb528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1414392abb5dc2f60386130ad8ad5130"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD&gt; </td></tr>
<tr class="memitem:a1414392abb5dc2f60386130ad8ad5130"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a1414392abb5dc2f60386130ad8ad5130">ExclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD])</td></tr>
<tr class="memdesc:a1414392abb5dc2f60386130ad8ad5130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements.  <a href="#a1414392abb5dc2f60386130ad8ad5130">More...</a><br/></td></tr>
<tr class="separator:a1414392abb5dc2f60386130ad8ad5130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inclusive prefix scans</div></td></tr>
<tr class="memitem:a981f9bae42f6f9c5fe6950698b97d8d4"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a981f9bae42f6f9c5fe6950698b97d8d4"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a981f9bae42f6f9c5fe6950698b97d8d4">InclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op, T &amp;block_aggregate)</td></tr>
<tr class="memdesc:a981f9bae42f6f9c5fe6950698b97d8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#a981f9bae42f6f9c5fe6950698b97d8d4">More...</a><br/></td></tr>
<tr class="separator:a981f9bae42f6f9c5fe6950698b97d8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b750ea27539a71e46657f3d63fdbce6"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </td></tr>
<tr class="memitem:a0b750ea27539a71e46657f3d63fdbce6"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a0b750ea27539a71e46657f3d63fdbce6">InclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], ScanOp scan_op, T &amp;block_aggregate)</td></tr>
<tr class="memdesc:a0b750ea27539a71e46657f3d63fdbce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#a0b750ea27539a71e46657f3d63fdbce6">More...</a><br/></td></tr>
<tr class="separator:a0b750ea27539a71e46657f3d63fdbce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b987cb649f4aced568b77bd9ac18db6"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp , typename BlockPrefixOp &gt; </td></tr>
<tr class="memitem:a4b987cb649f4aced568b77bd9ac18db6"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a4b987cb649f4aced568b77bd9ac18db6">InclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op, T &amp;block_aggregate, BlockPrefixOp &amp;block_prefix_op)</td></tr>
<tr class="memdesc:a4b987cb649f4aced568b77bd9ac18db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#a4b987cb649f4aced568b77bd9ac18db6">More...</a><br/></td></tr>
<tr class="separator:a4b987cb649f4aced568b77bd9ac18db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6c7a0cdb8ea21cd7eac0cecacd1ac1"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename ScanOp , typename BlockPrefixOp &gt; </td></tr>
<tr class="memitem:aae6c7a0cdb8ea21cd7eac0cecacd1ac1"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#aae6c7a0cdb8ea21cd7eac0cecacd1ac1">InclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], ScanOp scan_op, T &amp;block_aggregate, BlockPrefixOp &amp;block_prefix_op)</td></tr>
<tr class="memdesc:aae6c7a0cdb8ea21cd7eac0cecacd1ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#aae6c7a0cdb8ea21cd7eac0cecacd1ac1">More...</a><br/></td></tr>
<tr class="separator:aae6c7a0cdb8ea21cd7eac0cecacd1ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5220b7189e39eb4ff67430f732b1f96"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:ac5220b7189e39eb4ff67430f732b1f96"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#ac5220b7189e39eb4ff67430f732b1f96">InclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, ScanOp scan_op)</td></tr>
<tr class="memdesc:ac5220b7189e39eb4ff67430f732b1f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element.  <a href="#ac5220b7189e39eb4ff67430f732b1f96">More...</a><br/></td></tr>
<tr class="separator:ac5220b7189e39eb4ff67430f732b1f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046dfe9d6daa55a0d9c74d6ce2f7aa5b"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </td></tr>
<tr class="memitem:a046dfe9d6daa55a0d9c74d6ce2f7aa5b"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a046dfe9d6daa55a0d9c74d6ce2f7aa5b">InclusiveScan</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], ScanOp scan_op)</td></tr>
<tr class="memdesc:a046dfe9d6daa55a0d9c74d6ce2f7aa5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements.  <a href="#a046dfe9d6daa55a0d9c74d6ce2f7aa5b">More...</a><br/></td></tr>
<tr class="separator:a046dfe9d6daa55a0d9c74d6ce2f7aa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inclusive prefix sums</div></td></tr>
<tr class="memitem:a738fa570c0a0e391397c342eaab388cb"><td class="memItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a738fa570c0a0e391397c342eaab388cb">InclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T &amp;block_aggregate)</td></tr>
<tr class="memdesc:a738fa570c0a0e391397c342eaab388cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#a738fa570c0a0e391397c342eaab388cb">More...</a><br/></td></tr>
<tr class="separator:a738fa570c0a0e391397c342eaab388cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a16a5a98fadb09fa216b2d234f0b86"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD&gt; </td></tr>
<tr class="memitem:a88a16a5a98fadb09fa216b2d234f0b86"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a88a16a5a98fadb09fa216b2d234f0b86">InclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], T &amp;block_aggregate)</td></tr>
<tr class="memdesc:a88a16a5a98fadb09fa216b2d234f0b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#a88a16a5a98fadb09fa216b2d234f0b86">More...</a><br/></td></tr>
<tr class="separator:a88a16a5a98fadb09fa216b2d234f0b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed86bb94fe1908673dadbbaec0f95362"><td class="memTemplParams" colspan="2">template&lt;typename BlockPrefixOp &gt; </td></tr>
<tr class="memitem:aed86bb94fe1908673dadbbaec0f95362"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#aed86bb94fe1908673dadbbaec0f95362">InclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output, T &amp;block_aggregate, BlockPrefixOp &amp;block_prefix_op)</td></tr>
<tr class="memdesc:aed86bb94fe1908673dadbbaec0f95362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element. Instead of using 0 as the threadblock-wide prefix, the call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#aed86bb94fe1908673dadbbaec0f95362">More...</a><br/></td></tr>
<tr class="separator:aed86bb94fe1908673dadbbaec0f95362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47978bae019da4e99c30519de96534a4"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD, typename BlockPrefixOp &gt; </td></tr>
<tr class="memitem:a47978bae019da4e99c30519de96534a4"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#a47978bae019da4e99c30519de96534a4">InclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD], T &amp;block_aggregate, BlockPrefixOp &amp;block_prefix_op)</td></tr>
<tr class="memdesc:a47978bae019da4e99c30519de96534a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements. Instead of using 0 as the threadblock-wide prefix, the call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>.  <a href="#a47978bae019da4e99c30519de96534a4">More...</a><br/></td></tr>
<tr class="separator:a47978bae019da4e99c30519de96534a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bfc827149cbcfd741e578cfaeee5c7"><td class="memItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#af4bfc827149cbcfd741e578cfaeee5c7">InclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T input, T &amp;output)</td></tr>
<tr class="memdesc:af4bfc827149cbcfd741e578cfaeee5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element.  <a href="#af4bfc827149cbcfd741e578cfaeee5c7">More...</a><br/></td></tr>
<tr class="separator:af4bfc827149cbcfd741e578cfaeee5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9562dc6cb1e745c8714668dcef3e5b1"><td class="memTemplParams" colspan="2">template&lt;int ITEMS_PER_THREAD&gt; </td></tr>
<tr class="memitem:ae9562dc6cb1e745c8714668dcef3e5b1"><td class="memTemplItemLeft" align="right" valign="top">static __device__ <br class="typebreak"/>
__forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_scan.html#ae9562dc6cb1e745c8714668dcef3e5b1">InclusiveSum</a> (<a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;smem_storage, T(&amp;input)[ITEMS_PER_THREAD], T(&amp;output)[ITEMS_PER_THREAD])</td></tr>
<tr class="memdesc:ae9562dc6cb1e745c8714668dcef3e5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements.  <a href="#ae9562dc6cb1e745c8714668dcef3e5b1">More...</a><br/></td></tr>
<tr class="separator:ae9562dc6cb1e745c8714668dcef3e5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acc948eb8877a6d9956daebf258119b7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> threadblock-wide aggregate reduction of input items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64fbe22df260c4731536e1bbcec70cf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> threadblock-wide aggregate reduction of input items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa858e1cc0cee3e54fc3fb00bc0ecb3ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp , typename BlockPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>block_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>The <code>block_prefix_op</code> functor must implement a member function <code>T operator()(T block_aggregate)</code>. The functor's input parameter <code>block_aggregate</code> is the same value also returned by the scan operation. This functor is expected to return a threadblock-wide prefix to be applied to all inputs. The functor will be invoked by the entire first warp of threads, however the input and output are undefined in threads other than <em>thread</em><sub>0</sub>. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
    <tr><td class="paramname">BlockPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T block_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Threadblock-wide aggregate reduction of input items (exclusive of the <code>block_prefix_op</code> value) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_prefix_op</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Call-back functor for specifying a threadblock-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a7bf6b9e06e0ed3a71931f1694359f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename ScanOp , typename BlockPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>block_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>The <code>block_prefix_op</code> functor must implement a member function <code>T operator()(T block_aggregate)</code>. The functor's input parameter <code>block_aggregate</code> is the same value also returned by the scan operation. This functor is expected to return a threadblock-wide prefix to be applied to all inputs. The functor will be invoked by the entire first warp of threads, however the input and output are undefined in threads other than <em>thread</em><sub>0</sub>. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
    <tr><td class="paramname">BlockPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T block_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Threadblock-wide aggregate reduction of input items (exclusive of the <code>block_prefix_op</code> value) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_prefix_op</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Call-back functor for specifying a threadblock-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86857a9daede055f69299caff5b16259"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2cdb196b18b1d0eb3f7f85a57ed3ac7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a0090740c3b47eb018831f36d4fe307"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. With no identity value, the output computed for <em>thread</em><sub>0</sub> is invalid. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> threadblock-wide aggregate reduction of input items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a929f90d956502a7142fa780647241bf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. With no identity value, the output computed for <em>thread</em><sub>0</sub> is invalid. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> threadblock-wide aggregate reduction of input items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaea795b16f8a66dbbef62952b5f73643"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp , typename BlockPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>block_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>The <code>block_prefix_op</code> functor must implement a member function <code>T operator()(T block_aggregate)</code>. The functor's input parameter <code>block_aggregate</code> is the same value also returned by the scan operation. This functor is expected to return a threadblock-wide prefix to be applied to all inputs. The functor will be invoked by the entire first warp of threads, however the input and output are undefined in threads other than <em>thread</em><sub>0</sub>. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
    <tr><td class="paramname">BlockPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T block_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Threadblock-wide aggregate reduction of input items (exclusive of the <code>block_prefix_op</code> value) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_prefix_op</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Call-back functor for specifying a threadblock-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc79e233524e1e357a4cb77c44a46957"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename ScanOp , typename BlockPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>block_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>The <code>block_prefix_op</code> functor must implement a member function <code>T operator()(T block_aggregate)</code>. The functor's input parameter <code>block_aggregate</code> is the same value also returned by the scan operation. This functor is expected to return a threadblock-wide prefix to be applied to all inputs. The functor will be invoked by the entire first warp of threads, however the input and output are undefined in threads other than <em>thread</em><sub>0</sub>. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
    <tr><td class="paramname">BlockPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T block_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Threadblock-wide aggregate reduction of input items (exclusive of the <code>block_prefix_op</code> value) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_prefix_op</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Call-back functor for specifying a threadblock-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05c65595bc59cf1bb0fd04965f3b0988"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. With no identity value, the output computed for <em>thread</em><sub>0</sub> is invalid. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8d2690770ba251c6da988936f248da5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. With no identity value, the output computed for <em>thread</em><sub>0</sub> is invalid. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01676b552903e7b5d240bbde7968d55e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> threadblock-wide aggregate reduction of input items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4b6abbc17343b897a7b93d581620164"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> threadblock-wide aggregate reduction of input items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0fb65e2f9663daaee32390dee4c786b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename BlockPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>block_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element. Instead of using 0 as the threadblock-wide prefix, the call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>The <code>block_prefix_op</code> functor must implement a member function <code>T operator()(T block_aggregate)</code>. The functor's input parameter <code>block_aggregate</code> is the same value also returned by the scan operation. This functor is expected to return a threadblock-wide prefix to be applied to all inputs. The functor will be invoked by the entire first warp of threads, however the input and output are undefined in threads other than <em>thread</em><sub>0</sub>. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BlockPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T block_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Threadblock-wide aggregate reduction of input items (exclusive of the <code>block_prefix_op</code> value) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_prefix_op</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Call-back functor of the model <em>T block_prefix_op(T block_aggregate)</em> to be run <em>thread</em><sub>0</sub> for providing the operation with a threadblock-wide prefix value to seed the scan with. Can be stateful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9adb14da21b88da067e0dae60c628183"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename BlockPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>block_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements. Instead of using 0 as the threadblock-wide prefix, the call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>The <code>block_prefix_op</code> functor must implement a member function <code>T operator()(T block_aggregate)</code>. The functor's input parameter <code>block_aggregate</code> is the same value also returned by the scan operation. This functor is expected to return a threadblock-wide prefix to be applied to all inputs. The functor will be invoked by the entire first warp of threads, however the input and output are undefined in threads other than <em>thread</em><sub>0</sub>. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">BlockPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T block_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Threadblock-wide aggregate reduction of input items (exclusive of the <code>block_prefix_op</code> value) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_prefix_op</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Call-back functor for specifying a threadblock-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e661f683b84c496a0f1bcd96d5bb528"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1414392abb5dc2f60386130ad8ad5130"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a981f9bae42f6f9c5fe6950698b97d8d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> threadblock-wide aggregate reduction of input items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b750ea27539a71e46657f3d63fdbce6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> threadblock-wide aggregate reduction of input items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b987cb649f4aced568b77bd9ac18db6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp , typename BlockPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>block_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>The <code>block_prefix_op</code> functor must implement a member function <code>T operator()(T block_aggregate)</code>. The functor's input parameter <code>block_aggregate</code> is the same value also returned by the scan operation. This functor is expected to return a threadblock-wide prefix to be applied to all inputs. The functor will be invoked by the entire first warp of threads, however the input and output are undefined in threads other than <em>thread</em><sub>0</sub>. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
    <tr><td class="paramname">BlockPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T block_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Threadblock-wide aggregate reduction of input items (exclusive of the <code>block_prefix_op</code> value) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_prefix_op</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Call-back functor for specifying a threadblock-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae6c7a0cdb8ea21cd7eac0cecacd1ac1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename ScanOp , typename BlockPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>block_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. The call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>The <code>block_prefix_op</code> functor must implement a member function <code>T operator()(T block_aggregate)</code>. The functor's input parameter <code>block_aggregate</code> is the same value also returned by the scan operation. This functor is expected to return a threadblock-wide prefix to be applied to all inputs. The functor will be invoked by the entire first warp of threads, however the input and output are undefined in threads other than <em>thread</em><sub>0</sub>. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
    <tr><td class="paramname">BlockPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T block_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Threadblock-wide aggregate reduction of input items (exclusive of the <code>block_prefix_op</code> value) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_prefix_op</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Call-back functor for specifying a threadblock-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5220b7189e39eb4ff67430f732b1f96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes one input element. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a046dfe9d6daa55a0d9c74d6ce2f7aa5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using the specified binary <code>scan_op</code> functor. Each thread contributes an array of consecutive input elements. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a738fa570c0a0e391397c342eaab388cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> threadblock-wide aggregate reduction of input items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88a16a5a98fadb09fa216b2d234f0b86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> threadblock-wide aggregate reduction of input items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed86bb94fe1908673dadbbaec0f95362"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;typename BlockPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>block_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element. Instead of using 0 as the threadblock-wide prefix, the call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>The <code>block_prefix_op</code> functor must implement a member function <code>T operator()(T block_aggregate)</code>. The functor's input parameter <code>block_aggregate</code> is the same value also returned by the scan operation. This functor is expected to return a threadblock-wide prefix to be applied to all inputs. The functor will be invoked by the entire first warp of threads, however the input and output are undefined in threads other than <em>thread</em><sub>0</sub>. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BlockPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T block_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Threadblock-wide aggregate reduction of input items (exclusive of the <code>block_prefix_op</code> value) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_prefix_op</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Call-back functor for specifying a threadblock-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47978bae019da4e99c30519de96534a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD, typename BlockPrefixOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>block_aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockPrefixOp &amp;&#160;</td>
          <td class="paramname"><em>block_prefix_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements. Instead of using 0 as the threadblock-wide prefix, the call-back functor <code>block_prefix_op</code> is invoked to provide the "seed" value that logically prefixes the threadblock's scan inputs. The inclusive threadblock-wide <code>block_aggregate</code> of all inputs is computed for <em>thread</em><sub>0</sub>. </p>
<p>The scalar <code>block_aggregate</code> is undefined in threads other than <em>thread</em><sub>0</sub>.</p>
<p>The <code>block_prefix_op</code> functor must implement a member function <code>T operator()(T block_aggregate)</code>. The functor's input parameter <code>block_aggregate</code> is the same value also returned by the scan operation. This functor is expected to return a threadblock-wide prefix to be applied to all inputs. The functor will be invoked by the entire first warp of threads, however the input and output are undefined in threads other than <em>thread</em><sub>0</sub>. Can be stateful.</p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
    <tr><td class="paramname">BlockPrefixOp</td><td><b>[inferred]</b> Call-back functor type having member <code>T operator()(T block_aggregate)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_aggregate</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Threadblock-wide aggregate reduction of input items (exclusive of the <code>block_prefix_op</code> value) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block_prefix_op</td><td><b>[<em>thread</em><sub>0</sub> only]</b> Call-back functor for specifying a threadblock-wide prefix to be applied to all inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4bfc827149cbcfd741e578cfaeee5c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes one input element. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item (may be aliased to <code>input</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9562dc6cb1e745c8714668dcef3e5b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BLOCK_THREADS, BlockScanPolicy POLICY = BLOCK_SCAN_RAKING&gt; </div>
<div class="memtemplate">
template&lt;int ITEMS_PER_THREAD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ __forceinline__ void <a class="el" href="classcub_1_1_block_scan.html">cub::BlockScan</a>&lt; T, BLOCK_THREADS, POLICY &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcub_1_1_block_scan.html#abda6008896e2e17b50c7deb0ab320e64">SmemStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>smem_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>input</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>output</em>[ITEMS_PER_THREAD]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive threadblock-wide prefix scan using addition (+) as the scan operator. Each thread contributes an array of consecutive input elements. </p>
<p>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the supplied <code>smem_storage</code> is to be reused or repurposed by the threadblock.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td><b>[inferred]</b> The number of consecutive items partitioned onto each thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smem_storage</td><td>Shared reference to opaque SmemStorage layout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output items (may be aliased to <code>input</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="block__scan_8cuh.html">block_scan.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 23 2013 08:00:38 for CUB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
<br>
&copy; 2013 NVIDIA Corporation
</small></address>
</body>
</html>
