<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CUB: cub::WarpScan&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecub.html">cub</a></li><li class="navelem"><a class="el" href="classcub_1_1_warp_scan.html">WarpScan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classcub_1_1_warp_scan-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cub::WarpScan&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___warp_module.html">Warp-wide</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><h3>template&lt;
    typename T, 
    int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, 
    int PTX_ARCH = CUB_PTX_ARCH&gt;<br/>
class cub::WarpScan&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;</h3>

<p>The <a class="el" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">WarpScan</a> class provides <a href="index.html#sec0"><em>collective</em></a> methods for computing a parallel prefix scan of items partitioned across a CUDA thread warp. </p>
<div class="image">
<img src="warp_scan_logo.png" alt="warp_scan_logo.png"/>
<div class="caption">
.</div></div>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scan input/output element type </td></tr>
    <tr><td class="paramname">LOGICAL_WARP_THREADS</td><td><b>[optional]</b> The number of threads per "logical" warp (may be less than the number of hardware warp threads). Default is the warp size associated with the CUDA Compute Capability targeted by the compiler (e.g., 32 threads for SM20). </td></tr>
    <tr><td class="paramname">PTX_ARCH</td><td><b>[optional]</b> The PTX compute capability for which to to specialize this collective, formatted as per the <code><b>CUDA_ARCH</b></code> macro (e.g., 350 for sm_35). Useful for determining the collective's storage requirements for a given device from the host. (Default: the value of <code><b>CUDA_ARCH</b></code> during the current compiler pass)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Overview</dt><dd><ul>
<li>Given a list of input elements and a binary reduction operator, a <a href="http://en.wikipedia.org/wiki/Prefix_sum"><em>prefix scan</em></a> produces an output list where each element is computed to be the reduction of the elements occurring earlier in the input list. <em>Prefix sum</em> connotes a prefix scan with the addition operator. The term <em>inclusive</em> indicates that the <em>i</em><sup>th</sup> output reduction incorporates the <em>i</em><sup>th</sup> input. The term <em>exclusive</em> indicates the <em>i</em><sup>th</sup> input is not incorporated into the <em>i</em><sup>th</sup> output reduction.</li>
<li>Supports non-commutative scan operators</li>
<li>Supports "logical" warps smaller than the physical warp size (e.g., a logical warp of 8 threads)</li>
<li>The number of entrant threads must be an multiple of <code>LOGICAL_WARP_THREADS</code> </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance Considerations</dt><dd><ul>
<li>Uses special instructions when applicable (e.g., warp <code>SHFL</code>)</li>
<li>Uses synchronization-free communication between warp lanes when applicable</li>
<li>Incurs zero bank conflicts for most types</li>
<li>Computation is slightly more efficient (i.e., having lower instruction overhead) for:<ul>
<li>Summation (<b><em>vs.</em></b> generic scan)</li>
<li>The architecture's warp size is a whole multiple of <code>LOGICAL_WARP_THREADS</code> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Simple Examples</dt><dd>Every thread in the warp uses the <a class="el" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">WarpScan</a> class by first specializing the <a class="el" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">WarpScan</a> type, then instantiating an instance with parameters for communication, and finally invoking or more collective member functions. </dd></dl>
<dl class="section user"><dt></dt><dd>The code snippet below illustrates four concurrent warp prefix sums within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute warp-wide prefix sums</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).ExclusiveSum(thread_data, thread_data);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{1, 1, 1, 1, ...}</code>. The corresponding output <code>thread_data</code> in each of the four warps of threads will be <code>0, 1, 2, 3, ..., 31}</code>.</dd></dl>
<dl class="section user"><dt></dt><dd>The code snippet below illustrates a single warp prefix sum within a block of 128 threads. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for one warp</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage;</div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Only the first warp performs a prefix sum</span></div>
<div class="line">    <span class="keywordflow">if</span> (threadIdx.x &lt; 32)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">        <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Compute warp-wide prefix sums</span></div>
<div class="line">        <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage).ExclusiveSum(thread_data, thread_data);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the warp of threads is <code>{1, 1, 1, 1, ...}</code>. The corresponding output <code>thread_data</code> will be <code>{0, 1, 2, 3, ..., 31}</code>. </dd></dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00146">146</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcub_1_1_warp_scan_1_1_temp_storage.html">TempStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operations exposed by <a class="el" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">WarpScan</a> require a temporary memory allocation of this nested type for thread communication. This opaque storage can be allocated directly using the <code>__shared__</code> keyword. Alternatively, it can be aliased to externally allocated memory (shared or global) or <code>union</code>'d with other storage allocation types to facilitate memory reuse.  <a href="structcub_1_1_warp_scan_1_1_temp_storage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Collective constructors</div></td></tr>
<tr class="memitem:a97e8ea275768d3fed3be69e813675461"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461">WarpScan</a> (<a class="el" href="structcub_1_1_warp_scan_1_1_temp_storage.html">TempStorage</a> &amp;temp_storage)</td></tr>
<tr class="memdesc:a97e8ea275768d3fed3be69e813675461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from <code>threadIdx.x</code>.  <a href="#a97e8ea275768d3fed3be69e813675461">More...</a><br/></td></tr>
<tr class="separator:a97e8ea275768d3fed3be69e813675461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inclusive prefix sums</div></td></tr>
<tr class="memitem:a10ca8891d04473f6d80c74f66882c233"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a10ca8891d04473f6d80c74f66882c233">InclusiveSum</a> (T input, T &amp;output)</td></tr>
<tr class="memdesc:a10ca8891d04473f6d80c74f66882c233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum across the calling warp.  <a href="#a10ca8891d04473f6d80c74f66882c233">More...</a><br/></td></tr>
<tr class="separator:a10ca8891d04473f6d80c74f66882c233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89402b341ee33c5e0a9941d1fc3a69dc"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a89402b341ee33c5e0a9941d1fc3a69dc">InclusiveSum</a> (T input, T &amp;output, T &amp;warp_aggregate)</td></tr>
<tr class="memdesc:a89402b341ee33c5e0a9941d1fc3a69dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix sum across the calling warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#a89402b341ee33c5e0a9941d1fc3a69dc">More...</a><br/></td></tr>
<tr class="separator:a89402b341ee33c5e0a9941d1fc3a69dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exclusive prefix sums</div></td></tr>
<tr class="memitem:ae65304a415bfa8d4c8c38871fff50903"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#ae65304a415bfa8d4c8c38871fff50903">ExclusiveSum</a> (T input, T &amp;output)</td></tr>
<tr class="memdesc:ae65304a415bfa8d4c8c38871fff50903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix sum across the calling warp.  <a href="#ae65304a415bfa8d4c8c38871fff50903">More...</a><br/></td></tr>
<tr class="separator:ae65304a415bfa8d4c8c38871fff50903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51429741a6b14cb8b12e8118d958d976"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a51429741a6b14cb8b12e8118d958d976">ExclusiveSum</a> (T input, T &amp;output, T &amp;warp_aggregate)</td></tr>
<tr class="memdesc:a51429741a6b14cb8b12e8118d958d976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix sum across the calling warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#a51429741a6b14cb8b12e8118d958d976">More...</a><br/></td></tr>
<tr class="separator:a51429741a6b14cb8b12e8118d958d976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Inclusive prefix scans</div></td></tr>
<tr class="memitem:ae7cf1429e0d7d3895c40e6edbfe0ea48"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:ae7cf1429e0d7d3895c40e6edbfe0ea48"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#ae7cf1429e0d7d3895c40e6edbfe0ea48">InclusiveScan</a> (T input, T &amp;output, ScanOp scan_op)</td></tr>
<tr class="memdesc:ae7cf1429e0d7d3895c40e6edbfe0ea48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix scan using the specified binary scan functor across the calling warp.  <a href="#ae7cf1429e0d7d3895c40e6edbfe0ea48">More...</a><br/></td></tr>
<tr class="separator:ae7cf1429e0d7d3895c40e6edbfe0ea48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49afdc3dcafe6c12267bf714ceb7498"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:ae49afdc3dcafe6c12267bf714ceb7498"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#ae49afdc3dcafe6c12267bf714ceb7498">InclusiveScan</a> (T input, T &amp;output, ScanOp scan_op, T &amp;warp_aggregate)</td></tr>
<tr class="memdesc:ae49afdc3dcafe6c12267bf714ceb7498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an inclusive prefix scan using the specified binary scan functor across the calling warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#ae49afdc3dcafe6c12267bf714ceb7498">More...</a><br/></td></tr>
<tr class="separator:ae49afdc3dcafe6c12267bf714ceb7498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exclusive prefix scans</div></td></tr>
<tr class="memitem:a516f9ff0e402df4277f492db46aac78a"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a516f9ff0e402df4277f492db46aac78a"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a516f9ff0e402df4277f492db46aac78a">ExclusiveScan</a> (T input, T &amp;output, T identity, ScanOp scan_op)</td></tr>
<tr class="memdesc:a516f9ff0e402df4277f492db46aac78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor across the calling warp.  <a href="#a516f9ff0e402df4277f492db46aac78a">More...</a><br/></td></tr>
<tr class="separator:a516f9ff0e402df4277f492db46aac78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460cabefa9fce321b3f9673c9fbdb525"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a460cabefa9fce321b3f9673c9fbdb525"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a460cabefa9fce321b3f9673c9fbdb525">ExclusiveScan</a> (T input, T &amp;output, T identity, ScanOp scan_op, T &amp;warp_aggregate)</td></tr>
<tr class="memdesc:a460cabefa9fce321b3f9673c9fbdb525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor across the calling warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#a460cabefa9fce321b3f9673c9fbdb525">More...</a><br/></td></tr>
<tr class="separator:a460cabefa9fce321b3f9673c9fbdb525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Identityless exclusive prefix scans</div></td></tr>
<tr class="memitem:aaa70b8e943d8efafc8bc8f39b012a581"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:aaa70b8e943d8efafc8bc8f39b012a581"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#aaa70b8e943d8efafc8bc8f39b012a581">ExclusiveScan</a> (T input, T &amp;output, ScanOp scan_op)</td></tr>
<tr class="memdesc:aaa70b8e943d8efafc8bc8f39b012a581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor across the calling warp. Because no identity value is supplied, the <code>output</code> computed for <em>warp-lane</em><sub>0</sub> is undefined.  <a href="#aaa70b8e943d8efafc8bc8f39b012a581">More...</a><br/></td></tr>
<tr class="separator:aaa70b8e943d8efafc8bc8f39b012a581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf5e134de95f43d9c7749d6f1e22f2d"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:afdf5e134de95f43d9c7749d6f1e22f2d"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#afdf5e134de95f43d9c7749d6f1e22f2d">ExclusiveScan</a> (T input, T &amp;output, ScanOp scan_op, T &amp;warp_aggregate)</td></tr>
<tr class="memdesc:afdf5e134de95f43d9c7749d6f1e22f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix scan using the specified binary scan functor across the calling warp. Because no identity value is supplied, the <code>output</code> computed for <em>warp-lane</em><sub>0</sub> is undefined. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs.  <a href="#afdf5e134de95f43d9c7749d6f1e22f2d">More...</a><br/></td></tr>
<tr class="separator:afdf5e134de95f43d9c7749d6f1e22f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Combination (inclusive &amp; exclusive) prefix scans</div></td></tr>
<tr class="memitem:a25bd83f795e88b9260ec2bcbf846fb20"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a25bd83f795e88b9260ec2bcbf846fb20">Sum</a> (T input, T &amp;inclusive_output, T &amp;exclusive_output)</td></tr>
<tr class="memdesc:a25bd83f795e88b9260ec2bcbf846fb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both inclusive and exclusive prefix sums across the calling warp.  <a href="#a25bd83f795e88b9260ec2bcbf846fb20">More...</a><br/></td></tr>
<tr class="separator:a25bd83f795e88b9260ec2bcbf846fb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a247bea83254e7c3f3ae4ed8a1d5c7"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a32a247bea83254e7c3f3ae4ed8a1d5c7"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a32a247bea83254e7c3f3ae4ed8a1d5c7">Scan</a> (T input, T &amp;inclusive_output, T &amp;exclusive_output, T identity, ScanOp scan_op)</td></tr>
<tr class="memdesc:a32a247bea83254e7c3f3ae4ed8a1d5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both inclusive and exclusive prefix scans using the specified binary scan functor across the calling warp.  <a href="#a32a247bea83254e7c3f3ae4ed8a1d5c7">More...</a><br/></td></tr>
<tr class="separator:a32a247bea83254e7c3f3ae4ed8a1d5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3266a375b79e44f77087cec512e0c1a3"><td class="memTemplParams" colspan="2">template&lt;typename ScanOp &gt; </td></tr>
<tr class="memitem:a3266a375b79e44f77087cec512e0c1a3"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a3266a375b79e44f77087cec512e0c1a3">Scan</a> (T input, T &amp;inclusive_output, T &amp;exclusive_output, ScanOp scan_op)</td></tr>
<tr class="memdesc:a3266a375b79e44f77087cec512e0c1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both inclusive and exclusive prefix scans using the specified binary scan functor across the calling warp. Because no identity value is supplied, the <code>exclusive_output</code> computed for <em>warp-lane</em><sub>0</sub> is undefined.  <a href="#a3266a375b79e44f77087cec512e0c1a3">More...</a><br/></td></tr>
<tr class="separator:a3266a375b79e44f77087cec512e0c1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data exchange</div></td></tr>
<tr class="memitem:a97e5ad8bd37d95b39f9f7dee8254d9ad"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_warp_scan.html#a97e5ad8bd37d95b39f9f7dee8254d9ad">Broadcast</a> (T input, unsigned int src_lane)</td></tr>
<tr class="memdesc:a97e5ad8bd37d95b39f9f7dee8254d9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast the value <code>input</code> from <em>warp-lane</em><sub><code>src_lane</code></sub> to all lanes in the warp.  <a href="#a97e5ad8bd37d95b39f9f7dee8254d9ad">More...</a><br/></td></tr>
<tr class="separator:a97e5ad8bd37d95b39f9f7dee8254d9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97e8ea275768d3fed3be69e813675461"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::<a class="el" href="classcub_1_1_warp_scan.html">WarpScan</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcub_1_1_warp_scan_1_1_temp_storage.html">TempStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>temp_storage</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from <code>threadIdx.x</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">temp_storage</td><td>Reference to memory allocation having layout type <a class="el" href="structcub_1_1_warp_scan_1_1_temp_storage.html" title="The operations exposed by WarpScan require a temporary memory allocation of this nested type for thre...">TempStorage</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00203">203</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a10ca8891d04473f6d80c74f66882c233"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum across the calling warp. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide inclusive prefix sums within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute inclusive warp-wide prefix sums</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).InclusiveSum(thread_data, thread_data);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{1, 1, 1, 1, ...}</code>. The corresponding output <code>thread_data</code> in each of the four warps of threads will be <code>1, 2, 3, ..., 32}</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00254">254</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a89402b341ee33c5e0a9941d1fc3a69dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::InclusiveSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix sum across the calling warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide inclusive prefix sums within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute inclusive warp-wide prefix sums</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_aggregate;</div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).InclusiveSum(thread_data, thread_data, warp_aggregate);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{1, 1, 1, 1, ...}</code>. The corresponding output <code>thread_data</code> in each of the four warps of threads will be <code>1, 2, 3, ..., 32}</code>. Furthermore, <code>warp_aggregate</code> for all threads in all warps will be <code>32</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td>Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00297">297</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="ae65304a415bfa8d4c8c38871fff50903"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix sum across the calling warp. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>This operation assumes the value of obtained by the <code>T</code>'s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value zero for addition.</li>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide exclusive prefix sums within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute exclusive warp-wide prefix sums</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).ExclusiveSum(thread_data, thread_data);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{1, 1, 1, 1, ...}</code>. The corresponding output <code>thread_data</code> in each of the four warps of threads will be <code>0, 1, 2, ..., 31}</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00349">349</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a51429741a6b14cb8b12e8118d958d976"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix sum across the calling warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>This operation assumes the value of obtained by the <code>T</code>'s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value zero for addition.</li>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide exclusive prefix sums within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute exclusive warp-wide prefix sums</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_aggregate;</div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).ExclusiveSum(thread_data, thread_data, warp_aggregate);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{1, 1, 1, 1, ...}</code>. The corresponding output <code>thread_data</code> in each of the four warps of threads will be <code>0, 1, 2, ..., 31}</code>. Furthermore, <code>warp_aggregate</code> for all threads in all warps will be <code>32</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td>Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00393">393</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="ae7cf1429e0d7d3895c40e6edbfe0ea48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix scan using the specified binary scan functor across the calling warp. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide inclusive prefix max scans within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute inclusive warp-wide prefix max scans</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).InclusiveScan(thread_data, thread_data, <a class="code" href="structcub_1_1_max.html" title="Default max functor. ">cub::Max</a>());</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{0, -1, 2, -3, ..., 126, -127}</code>. The corresponding output <code>thread_data</code> in the first warp would be <code>0, 0, 2, 2, ..., 30, 30</code>, the output for the second warp would be <code>32, 32, 34, 34, ..., 62, 62</code>, etc.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00445">445</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="ae49afdc3dcafe6c12267bf714ceb7498"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::InclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an inclusive prefix scan using the specified binary scan functor across the calling warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide inclusive prefix max scans within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute inclusive warp-wide prefix max scans</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_aggregate;</div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).InclusiveScan(</div>
<div class="line">        thread_data, thread_data, <a class="code" href="structcub_1_1_max.html" title="Default max functor. ">cub::Max</a>(), warp_aggregate);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{0, -1, 2, -3, ..., 126, -127}</code>. The corresponding output <code>thread_data</code> in the first warp would be <code>0, 0, 2, 2, ..., 30, 30</code>, the output for the second warp would be <code>32, 32, 34, 34, ..., 62, 62</code>, etc. Furthermore, <code>warp_aggregate</code> would be assigned <code>30</code> for threads in the first warp, <code>62</code> for threads in the second warp, etc.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td>Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00495">495</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a516f9ff0e402df4277f492db46aac78a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor across the calling warp. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide exclusive prefix max scans within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute exclusive warp-wide prefix max scans</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).ExclusiveScan(thread_data, thread_data, INT_MIN, <a class="code" href="structcub_1_1_max.html" title="Default max functor. ">cub::Max</a>());</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{0, -1, 2, -3, ..., 126, -127}</code>. The corresponding output <code>thread_data</code> in the first warp would be <code>INT_MIN, 0, 0, 2, ..., 28, 30</code>, the output for the second warp would be <code>30, 32, 32, 34, ..., 60, 62</code>, etc.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00548">548</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a460cabefa9fce321b3f9673c9fbdb525"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor across the calling warp. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide exclusive prefix max scans within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute exclusive warp-wide prefix max scans</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_aggregate;</div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).ExclusiveScan(thread_data, thread_data, INT_MIN, <a class="code" href="structcub_1_1_max.html" title="Default max functor. ">cub::Max</a>(), warp_aggregate);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{0, -1, 2, -3, ..., 126, -127}</code>. The corresponding output <code>thread_data</code> in the first warp would be <code>INT_MIN, 0, 0, 2, ..., 28, 30</code>, the output for the second warp would be <code>30, 32, 32, 34, ..., 60, 62</code>, etc. Furthermore, <code>warp_aggregate</code> would be assigned <code>30</code> for threads in the first warp, <code>62</code> for threads in the second warp, etc.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td>Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00598">598</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="aaa70b8e943d8efafc8bc8f39b012a581"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor across the calling warp. Because no identity value is supplied, the <code>output</code> computed for <em>warp-lane</em><sub>0</sub> is undefined. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide exclusive prefix max scans within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute exclusive warp-wide prefix max scans</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).ExclusiveScan(thread_data, thread_data, <a class="code" href="structcub_1_1_max.html" title="Default max functor. ">cub::Max</a>());</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{0, -1, 2, -3, ..., 126, -127}</code>. The corresponding output <code>thread_data</code> in the first warp would be <code>?, 0, 0, 2, ..., 28, 30</code>, the output for the second warp would be <code>?, 32, 32, 34, ..., 60, 62</code>, etc. (The output <code>thread_data</code> in warp lane<sub>0</sub> is undefined.)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00654">654</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="afdf5e134de95f43d9c7749d6f1e22f2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::ExclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>warp_aggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an exclusive prefix scan using the specified binary scan functor across the calling warp. Because no identity value is supplied, the <code>output</code> computed for <em>warp-lane</em><sub>0</sub> is undefined. Also provides every thread with the warp-wide <code>warp_aggregate</code> of all inputs. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide exclusive prefix max scans within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute exclusive warp-wide prefix max scans</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_aggregate;</div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).ExclusiveScan(thread_data, thread_data, <a class="code" href="structcub_1_1_max.html" title="Default max functor. ">cub::Max</a>(), warp_aggregate);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{0, -1, 2, -3, ..., 126, -127}</code>. The corresponding output <code>thread_data</code> in the first warp would be <code>?, 0, 0, 2, ..., 28, 30</code>, the output for the second warp would be <code>?, 32, 32, 34, ..., 60, 62</code>, etc. (The output <code>thread_data</code> in warp lane<sub>0</sub> is undefined.) Furthermore, <code>warp_aggregate</code> would be assigned <code>30</code> for threads in the first warp, <code>62</code> for threads in the second warp, etc.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Calling thread's output item. May be aliased with <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">warp_aggregate</td><td>Warp-wide aggregate reduction of input items. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00703">703</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a25bd83f795e88b9260ec2bcbf846fb20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::<a class="el" href="structcub_1_1_sum.html">Sum</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>inclusive_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>exclusive_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both inclusive and exclusive prefix sums across the calling warp. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>This operation assumes the value of obtained by the <code>T</code>'s default constructor (or by zero-initialization if no user-defined default constructor exists) is suitable as the identity value zero for addition.</li>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide prefix sums within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute in|exclusive warp-wide prefix sums</span></div>
<div class="line">    <span class="keywordtype">int</span> inclusive_partial, exclusive_partial;</div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).Sum(thread_data, inclusive_partial, exclusive_partial);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{1, 1, 1, 1, ...}</code>. The corresponding output <code>inclusive_partial</code> in each of the four warps of threads will be <code>1, 2, 3, ..., 32}</code>. The corresponding output <code>exclusive_partial</code> in each of the four warps of threads will be <code>0, 1, 2, ..., 31}</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inclusive_output</td><td>Calling thread's inclusive-scan output item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exclusive_output</td><td>Calling thread's exclusive-scan output item. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00759">759</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a32a247bea83254e7c3f3ae4ed8a1d5c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::Scan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>inclusive_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>exclusive_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both inclusive and exclusive prefix scans using the specified binary scan functor across the calling warp. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide prefix max scans within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute inclusive warp-wide prefix max scans</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    <span class="keywordtype">int</span> inclusive_partial, exclusive_partial;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).Scan(thread_data, inclusive_partial, exclusive_partial, INT_MIN, <a class="code" href="structcub_1_1_max.html" title="Default max functor. ">cub::Max</a>());</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{0, -1, 2, -3, ..., 126, -127}</code>. The corresponding output <code>inclusive_partial</code> in the first warp would be <code>0, 0, 2, 2, ..., 30, 30</code>, the output for the second warp would be <code>32, 32, 34, 34, ..., 62, 62</code>, etc. The corresponding output <code>exclusive_partial</code> in the first warp would be <code>INT_MIN, 0, 0, 2, ..., 28, 30</code>, the output for the second warp would be <code>30, 32, 32, 34, ..., 60, 62</code>, etc.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inclusive_output</td><td>Calling thread's inclusive-scan output item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exclusive_output</td><td>Calling thread's exclusive-scan output item. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">identity</td><td>Identity value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00808">808</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a3266a375b79e44f77087cec512e0c1a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename ScanOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::Scan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>inclusive_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>exclusive_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScanOp&#160;</td>
          <td class="paramname"><em>scan_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both inclusive and exclusive prefix scans using the specified binary scan functor across the calling warp. Because no identity value is supplied, the <code>exclusive_output</code> computed for <em>warp-lane</em><sub>0</sub> is undefined. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates four concurrent warp-wide exclusive prefix max scans within a block of 128 threads (one per each of the 32-thread warps). </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compute exclusive warp-wide prefix max scans</span></div>
<div class="line">    <span class="keywordtype">int</span> inclusive_partial, exclusive_partial;</div>
<div class="line">    <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).Scan(thread_data, inclusive_partial, exclusive_partial, <a class="code" href="structcub_1_1_max.html" title="Default max functor. ">cub::Max</a>());</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{0, -1, 2, -3, ..., 126, -127}</code>. The corresponding output <code>inclusive_partial</code> in the first warp would be <code>0, 0, 2, 2, ..., 30, 30</code>, the output for the second warp would be <code>32, 32, 34, 34, ..., 62, 62</code>, etc. The corresponding output <code>exclusive_partial</code> in the first warp would be <code>?, 0, 0, 2, ..., 28, 30</code>, the output for the second warp would be <code>?, 32, 32, 34, ..., 60, 62</code>, etc. (The output <code>thread_data</code> in warp lane<sub>0</sub> is undefined.)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScanOp</td><td><b>[inferred]</b> Binary scan operator type having member <code>T operator()(const T &amp;a, const T &amp;b)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Calling thread's input item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inclusive_output</td><td>Calling thread's inclusive-scan output item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exclusive_output</td><td>Calling thread's exclusive-scan output item. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_op</td><td>Binary scan operator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00859">859</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a97e5ad8bd37d95b39f9f7dee8254d9ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ T <a class="el" href="classcub_1_1_warp_scan.html">cub::WarpScan</a>&lt; T, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::Broadcast </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>src_lane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast the value <code>input</code> from <em>warp-lane</em><sub><code>src_lane</code></sub> to all lanes in the warp. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the warp-wide broadcasts of values from lanes<sub>0</sub> in each of four warps to all other threads in those warps. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Specialize WarpScan for type int</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classcub_1_1_warp_scan.html" title="The WarpScan class provides collective methods for computing a parallel prefix scan of items partitio...">cub::WarpScan&lt;int&gt;</a> <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate WarpScan shared memory for 4 warps</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpScan::TempStorage temp_storage[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain one input item per thread</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data = ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Broadcast from lane0 in each warp to all other threads in the warp</span></div>
<div class="line">    <span class="keywordtype">int</span> warp_id = threadIdx.x / 32;</div>
<div class="line">    thread_data = <a class="code" href="classcub_1_1_warp_scan.html#a97e8ea275768d3fed3be69e813675461" title="Collective constructor using the specified memory allocation as temporary storage. Logical warp and lane identifiers are constructed from threadIdx.x. ">WarpScan</a>(temp_storage[warp_id]).Broadcast(thread_data, 0);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{0, 1, 2, 3, ..., 127}</code>. The corresponding output <code>thread_data</code> will be <code>{0, 0, ..., 0}</code> in warp<sub>0</sub>, <code>{32, 32, ..., 32}</code> in warp<sub>1</sub>, <code>{64, 64, ..., 64}</code> in warp<sub>2</sub>, etc. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The value to broadcast </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_lane</td><td>Which warp lane is to do the broadcasting </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="warp__scan_8cuh_source.html#l00910">910</a> of file <a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="warp__scan_8cuh_source.html">warp_scan.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 21 2016 13:28:14 for CUB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
<br>
&copy; 2013 NVIDIA Corporation
</small></address>
</body>
</html>
